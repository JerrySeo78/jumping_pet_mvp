<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Jumping Pet - Ï†êÌïëÌé´</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #1a1a2e;
  display: flex; justify-content: center; align-items: center;
  font-family: 'Segoe UI', sans-serif;
  touch-action: none;
  -webkit-user-select: none; user-select: none;
}
canvas { display: block; max-width: 100vw; max-height: 100vh; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = 400, H = 720;
canvas.width = W; canvas.height = H;

function resizeCanvas() {
  const s = Math.min(window.innerWidth / W, window.innerHeight / H);
  canvas.style.width = (W * s) + 'px';
  canvas.style.height = (H * s) + 'px';
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const LANE_X = [W * 0.28, W * 0.72];
const ROW_H = 100;
const STATE = { MENU: 0, PLAY: 1, OVER: 2 };
const PET_SCREEN_Y = H * 0.62; // pet stays at ~62% down the screen

const C = {
  sky1:'#d4edf9', sky2:'#e8f4fd', sky3:'#f0e6f6',
  ice:'#b8dff0', iceDeep:'#7bbcd6', purpleDeep:'#7a5ba8',
  green:'#5cb85c', pinkBg:'#fde0ef', candy:'#c77dff',
  brown:'#6b4226', bone:'#f5deb3',
};

let gs = STATE.MENU;
let score = 0, highScore = +localStorage.getItem('jpH') || 0;
let level = 1, heightM = 0, candies = 0;
let fever = 0, isFever = false, feverT = 0;
let camY = 0;
let autoScrollSpeed = 0.4, baseAutoScroll = 0.4;
let rows = [];
let particles = [], gt = 0, shakeT = 0;
let gameOverAlpha = 0;
let jumpTxt = { on: false, t: 0 };

let jumpA = {
  on: false, t: 0, dur: 0,
  fx: 0, fy: 0, tx: 0, ty: 0, pk: 0,
  custom: false, midX: 0,
  onComplete: null,
};

const pet = { lane: 0, row: 0, x: LANE_X[0], y: 0, face: 1 };

// ============================================
// ROW SYSTEM
// ============================================
function makeRow(index) {
  let left = false, right = false;
  if (index <= 1) { left = true; right = true; }
  else {
    const r = Math.random();
    if (r < 0.3) { left = true; }
    else if (r < 0.6) { right = true; }
    else { left = true; right = true; }
  }
  const isPurple = index > 5 && Math.random() < 0.12;
  return {
    index, y: -index * ROW_H,
    left, right,
    leftCandy: left && index > 2 && Math.random() < 0.14,
    rightCandy: right && index > 2 && Math.random() < 0.14,
    leftCandyGot: false, rightCandyGot: false,
    leftPurple: left && isPurple,
    rightPurple: right && isPurple,
    leftBroken: false, rightBroken: false,
    leftWobble: 0, rightWobble: 0,
    feverOverride: false,
  };
}

function initRows() {
  rows = [];
  for (let i = 0; i < 35; i++) rows.push(makeRow(i));
}

function ensureRows() {
  const maxIdx = rows[rows.length - 1].index;
  const needed = Math.floor(-camY / ROW_H) + 25;
  for (let i = maxIdx + 1; i <= needed; i++) rows.push(makeRow(i));
  rows = rows.filter(r => r.y - camY < H + 300);
}

function getRow(idx) { return rows.find(r => r.index === idx); }
function hasPlat(row, lane) {
  if (!row) return false;
  return lane === 0 ? (row.left && !row.leftBroken) : (row.right && !row.rightBroken);
}

// ============================================
// FEVER
// ============================================
function applyFever() {
  rows.forEach(r => {
    if (!r.feverOverride) {
      r.feverOverride = true;
      r._oL = r.left; r._oR = r.right;
      r._oLC = r.leftCandy; r._oRC = r.rightCandy;
      r.left = true; r.right = true;
      if (!r.leftCandy && !r.leftCandyGot) r.leftCandy = true;
      if (!r.rightCandy && !r.rightCandyGot) r.rightCandy = true;
    }
  });
}

function removeFever() {
  rows.forEach(r => {
    if (r.feverOverride) {
      r.feverOverride = false;
      r.left = r._oL; r.right = r._oR;
      r.leftCandy = r._oLC; r.rightCandy = r._oRC;
    }
  });
}

// ============================================
// FIND TARGET
// ============================================
function findTarget(lane, fromRow) {
  // Up first
  const upRow = getRow(fromRow + 1);
  if (upRow && hasPlat(upRow, lane)) return { row: upRow, index: upRow.index };
  // Same row (lateral move)
  const curRow = getRow(fromRow);
  if (curRow && hasPlat(curRow, lane)) return { row: curRow, index: curRow.index };
  // Down
  for (let i = fromRow - 1; i >= fromRow - 10; i--) {
    const r = getRow(i);
    if (r && hasPlat(r, lane)) return { row: r, index: r.index };
  }
  return null;
}

// ============================================
// JUMP
// ============================================
function doJump(fx, fy, tx, ty, cb) {
  const dx = Math.abs(tx - fx);
  const dy = fy - ty;
  const peak = Math.min(fy, ty) - Math.max(50, dy * 0.3 + 40);
  jumpA = { on: true, t: 0, dur: dx < 10 ? 14 : 18, fx, fy, tx, ty, pk: peak, custom: false, midX: 0, onComplete: cb || null };
}

function doFall(fx, fy, tx, ty, cb) {
  jumpA = { on: true, t: 0, dur: 12, fx, fy, tx, ty, pk: Math.min(fy, ty) - 20, custom: false, midX: 0, onComplete: cb || null };
}

function updateJump() {
  if (!jumpA.on) return;
  jumpA.t++;
  const p = jumpA.t / jumpA.dur;
  if (p >= 1) {
    jumpA.on = false;
    pet.x = jumpA.tx; pet.y = jumpA.ty;
    if (jumpA.onComplete) jumpA.onComplete();
    return;
  }
  const q = 1 - p;
  if (jumpA.custom) {
    pet.x = jumpA.fx + (jumpA.midX - jumpA.fx) * Math.sin(p * Math.PI);
    pet.y = q * q * jumpA.fy + 2 * q * p * jumpA.pk + p * p * jumpA.ty;
  } else {
    pet.x = q * jumpA.fx + p * jumpA.tx;
    pet.y = q * q * jumpA.fy + 2 * q * p * jumpA.pk + p * p * jumpA.ty;
  }
}

// ============================================
// LANDING
// ============================================
function onLand() {
  const row = getRow(pet.row);
  if (!row) return;
  const lane = pet.lane;
  const isPurple = lane === 0 ? row.leftPurple : row.rightPurple;

  if (lane === 0 && row.leftCandy && !row.leftCandyGot) {
    row.leftCandyGot = true; candies++; score += 50; spawnP(LANE_X[0], row.y, C.candy, 6);
  }
  if (lane === 1 && row.rightCandy && !row.rightCandyGot) {
    row.rightCandyGot = true; candies++; score += 50; spawnP(LANE_X[1], row.y, C.candy, 6);
  }

  score += isFever ? 20 : 10;
  heightM = Math.max(heightM, Math.floor(pet.row * ROW_H / 10));
  level = Math.floor(heightM / 100) + 1;

  if (!isFever) {
    fever = Math.min(100, fever + 3);
    if (fever >= 100) {
      isFever = true; feverT = 360;
      applyFever(); spawnP(pet.x, pet.y, '#ff4081', 20);
    }
  }
  spawnP(pet.x, pet.y + 10, '#fff', 3);

  // Purple: schedule break after 1 second
  if (isPurple) {
    const breakRow = row;
    const breakLane = lane;
    const breakRowIdx = pet.row;
    // Wobble warning
    if (breakLane === 0) breakRow.leftWobble = gt;
    else breakRow.rightWobble = gt;

    setTimeout(() => {
      if (breakLane === 0) breakRow.leftBroken = true;
      else breakRow.rightBroken = true;
      shakeT = 5;
      spawnP(LANE_X[breakLane], breakRow.y, C.purpleDeep, 10);

      // If pet is still on this platform, make them fall
      if (pet.row === breakRowIdx && pet.lane === breakLane && !jumpA.on) {
        let fallTarget = null;
        for (let i = pet.row - 1; i >= pet.row - 15; i--) {
          const r = getRow(i);
          if (r && hasPlat(r, breakLane)) { fallTarget = { row: r, index: r.index }; break; }
        }
        if (fallTarget) {
          pet.row = fallTarget.index;
          doFall(pet.x, pet.y, LANE_X[breakLane], fallTarget.row.y, onLand);
        }
      }
    }, 1000);
  }
}

// ============================================
// INPUT
// ============================================
function handleInput(side) {
  if (gs === STATE.MENU) { startGame(); return; }
  if (gs === STATE.OVER) { startGame(); return; }
  if (jumpA.on) return;

  const target = findTarget(side, pet.row);
  pet.face = side === 1 ? 1 : -1;

  if (!target) {
    // No platform at all: bounce back
    jumpA = { on: true, t: 0, dur: 18, fx: pet.x, fy: pet.y, tx: pet.x, ty: pet.y, pk: pet.y - ROW_H, custom: true, midX: LANE_X[side], onComplete: null };
    return;
  }

  // Always jump UP to the height of next row first, then land on target
  const nextRowY = -(pet.row + 1) * ROW_H; // the y position one row above current
  const peakY = Math.min(nextRowY, target.row.y) - 30; // peak is at least next-row height

  pet.lane = side;
  pet.row = target.index;

  // If target is above or at same level: normal arc through peak
  // If target is below: still arc up to next-row height, then come down
  jumpA = {
    on: true, t: 0,
    dur: target.row.y > pet.y ? 24 : 18, // longer if falling down
    fx: pet.x, fy: pet.y,
    tx: LANE_X[side], ty: target.row.y,
    pk: peakY,
    custom: false, midX: 0,
    onComplete: onLand,
  };
  ensureRows();
}

function getPos(cx, cy) {
  const r = canvas.getBoundingClientRect();
  return { x: (cx - r.left) / r.width * W, y: (cy - r.top) / r.height * H };
}
canvas.addEventListener('touchstart', e => { e.preventDefault(); const p = getPos(e.touches[0].clientX, e.touches[0].clientY); handleInput(p.x > W / 2 ? 1 : 0); });
canvas.addEventListener('mousedown', e => { const p = getPos(e.clientX, e.clientY); handleInput(p.x > W / 2 ? 1 : 0); });
document.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft' || e.key === 'a') handleInput(0);
  if (e.key === 'ArrowRight' || e.key === 'd') handleInput(1);
  if ((e.key === ' ' || e.key === 'Enter') && gs !== STATE.PLAY) handleInput(0);
});

// ============================================
// PARTICLES
// ============================================
function spawnP(x, y, color, n = 5) {
  for (let i = 0; i < n; i++) particles.push({
    x, y, vx: (Math.random() - .5) * 6, vy: -Math.random() * 4 - 1,
    life: 1, dec: .025 + Math.random() * .02, sz: 3 + Math.random() * 4, color
  });
}

// ============================================
// CAMERA
// ============================================
function updateCamera() {
  // Target: keep pet at PET_SCREEN_Y on screen
  const targetCam = pet.y - PET_SCREEN_Y;

  // Auto scroll: camera always moves up at minimum speed
  autoScrollSpeed = baseAutoScroll + heightM * 0.002;
  if (isFever) autoScrollSpeed *= 0.65;

  const autoTarget = camY - autoScrollSpeed;

  // Camera follows the higher of: auto-scroll or player-tracking
  // (lower camY = higher on screen)
  const desiredCam = Math.min(autoTarget, targetCam);

  // Smooth follow
  camY += (desiredCam - camY) * 0.15;
}

// ============================================
// DRAWING
// ============================================
function rr(x, y, w, h, r) { ctx.beginPath(); ctx.roundRect(x, y, w, h, r); ctx.fill(); }

function drawBG() {
  const g = ctx.createLinearGradient(0, 0, 0, H);
  if (isFever) { g.addColorStop(0, C.pinkBg); g.addColorStop(1, '#f8bbd0'); }
  else { g.addColorStop(0, C.sky1); g.addColorStop(.5, C.sky2); g.addColorStop(1, C.sky3); }
  ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = isFever ? 'rgba(255,180,220,0.06)' : 'rgba(180,220,240,0.06)';
  rr(LANE_X[0] - 50, 0, 100, H, 0);
  rr(LANE_X[1] - 50, 0, 100, H, 0);

  ctx.strokeStyle = 'rgba(180,210,230,0.2)'; ctx.lineWidth = 1;
  ctx.setLineDash([8, 8]);
  ctx.beginPath(); ctx.moveTo(W / 2, 0); ctx.lineTo(W / 2, H); ctx.stroke();
  ctx.setLineDash([]);

  ctx.globalAlpha = .2; ctx.fillStyle = '#fff';
  for (let i = 0; i < 18; i++) {
    const sx = (i * 37 + camY * .04 * (i % 3 + 1)) % W;
    const sy = (i * 53 + camY * .06 * (i % 2 + 1)) % H;
    ctx.beginPath(); ctx.arc(sx, sy, 1 + (i % 3), 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  ctx.globalAlpha = .07; ctx.fillStyle = C.ice;
  const off = (-camY * .1) % 300;
  for (let i = 0; i < 5; i++) {
    const my = (i * 200 + off) % (H + 100) - 50;
    ctx.beginPath(); ctx.ellipse(-10, my, 45, 30, 0, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(W + 10, my + 80, 45, 30, 0, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  const interval = 2500;
  const base = Math.round(camY / interval) * interval - 300;
  for (let i = -1; i <= 1; i++) {
    const sy = base + i * interval - camY;
    if (sy < -250 || sy > H + 50) continue;
    ctx.globalAlpha = .06; ctx.fillStyle = '#d8c0e8';
    ctx.beginPath(); ctx.arc(W / 2, sy, 50, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.moveTo(W/2-40,sy-38); ctx.lineTo(W/2-52,sy-88); ctx.lineTo(W/2-10,sy-48); ctx.fill();
    ctx.beginPath(); ctx.moveTo(W/2+40,sy-38); ctx.lineTo(W/2+52,sy-88); ctx.lineTo(W/2+10,sy-48); ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function drawPlat(x, sy, purple, hasCandy, candyGot, rowIdx, wobbleStart) {
  const pw = 72, ph = 18, px = x - pw / 2, py = sy;
  // Wobble effect for purple about to break
  let wobbleX = 0;
  if (wobbleStart > 0) {
    const elapsed = (gt - wobbleStart) / 60; // seconds
    if (elapsed < 1) {
      const intensity = elapsed * 4; // gets stronger
      wobbleX = Math.sin(gt * 0.8) * intensity * 3;
    }
  }
  ctx.save();
  if (wobbleX) ctx.translate(wobbleX, 0);
  if (purple) {
    ctx.fillStyle = '#e0d0f0'; rr(px - 2, py - 2, pw + 4, ph + 4, 10);
    ctx.fillStyle = '#d4c4e8'; rr(px, py, pw, ph * .5, [8, 8, 2, 2]);
    ctx.fillStyle = C.purpleDeep; rr(px + 2, py + ph * .35, pw - 4, ph * .65, [2, 2, 8, 8]);
    ctx.fillStyle = 'rgba(255,255,255,.3)'; rr(px + 8, py + 3, pw * .25, 3, 2);
  } else {
    ctx.fillStyle = '#e8f5ff'; rr(px - 2, py - 2, pw + 4, ph + 4, 10);
    ctx.fillStyle = '#fff'; rr(px, py, pw, ph * .6, [8, 8, 2, 2]);
    ctx.fillStyle = C.iceDeep; rr(px + 2, py + ph * .4, pw - 4, ph * .6, [2, 2, 8, 8]);
    ctx.fillStyle = 'rgba(255,255,255,.6)'; rr(px + 8, py + 3, pw * .3, 4, 2);
  }
  if (isFever) { ctx.fillStyle = 'rgba(255,105,180,0.08)'; rr(px - 2, py - 2, pw + 4, ph + 4, 10); }
  if (hasCandy && !candyGot) {
    const b = Math.sin(gt * .08 + rowIdx) * 3;
    ctx.fillStyle = C.candy;
    rr(x - 7, py - 18 + b, 14, 10, 3);
    ctx.beginPath(); ctx.moveTo(x-7,py-15+b); ctx.lineTo(x-12,py-18+b); ctx.lineTo(x-7,py-11+b); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x+7,py-15+b); ctx.lineTo(x+12,py-18+b); ctx.lineTo(x+7,py-11+b); ctx.fill();
    ctx.fillStyle='rgba(255,255,255,.5)'; rr(x-3,py-16+b,4,3,1);
  }
  ctx.restore();
}

function drawRows() {
  rows.forEach(r => {
    const sy = r.y - camY;
    if (sy < -40 || sy > H + 40) return;
    if (r.left && !r.leftBroken) drawPlat(LANE_X[0], sy, r.leftPurple, r.leftCandy, r.leftCandyGot, r.index, r.leftWobble);
    if (r.right && !r.rightBroken) drawPlat(LANE_X[1], sy, r.rightPurple, r.rightCandy, r.rightCandyGot, r.index, r.rightWobble);
  });
}

function drawPet() {
  const sx = pet.x, sy = pet.y - camY;
  ctx.save(); ctx.translate(sx, sy);
  let scX = 1, scY = 1;
  if (jumpA.on) {
    const p = jumpA.t / jumpA.dur;
    if (p < .3) { scX = .85; scY = 1.2; } else if (p > .7) { scX = 1.1; scY = .9; }
  }
  ctx.scale(scX * pet.face, scY);
  if (isFever) {
    ctx.strokeStyle = 'rgba(255,200,240,.5)'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(0, -10, 30 + Math.sin(gt * .15) * 3, 0, Math.PI * 2); ctx.stroke();
    ctx.shadowColor = '#f8a4c8'; ctx.shadowBlur = 12;
  }
  ctx.fillStyle = '#f5e6d0';
  ctx.beginPath(); ctx.ellipse(0, -8, 16, 18, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#4a9bd9'; rr(-14, -2, 28, 18, 6);
  ctx.fillStyle = '#f5e6d0';
  ctx.beginPath(); ctx.ellipse(-16, 4, 6, 8, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(16, 4, 6, 8, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#f5e6d0';
  ctx.beginPath(); ctx.arc(0, -22, 15, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(-10, -35, 7, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(10, -35, 7, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#e8c4a0';
  ctx.beginPath(); ctx.arc(-10, -35, 4, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(10, -35, 4, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#2d8f4e';
  ctx.beginPath(); ctx.arc(0, -30, 13, Math.PI, 0); ctx.fill();
  rr(-14, -32, 28, 8, 3);
  ctx.fillStyle = '#1a6b35';
  for (let i = -10; i < 10; i += 5) ctx.fillRect(i, -32, 2, 6);
  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, -42, 5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#2c2c2c';
  ctx.beginPath(); ctx.arc(-5, -23, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(5, -23, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(-4, -24, 1, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(6, -24, 1, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#8B6F5E';
  ctx.beginPath(); ctx.arc(0, -19, 2, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#8B6F5E'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.arc(-2, -17, 3, 0, Math.PI * .7); ctx.stroke();
  ctx.beginPath(); ctx.arc(2, -17, 3, Math.PI * .3, Math.PI); ctx.stroke();
  ctx.fillStyle = 'rgba(255,150,150,.3)';
  ctx.beginPath(); ctx.ellipse(-10, -18, 4, 2.5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(10, -18, 4, 2.5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.restore(); ctx.shadowBlur = 0;
}

function drawUI() {
  ctx.fillStyle = C.brown; ctx.font = 'bold 22px sans-serif'; ctx.textAlign = 'left';
  ctx.fillText(`Lv. ${level}`, 15, 35);
  ctx.fillStyle = isFever ? '#e91e63' : '#e8a0c0'; ctx.font = 'bold 16px sans-serif';
  ctx.fillText(`${heightM}m`, 15, 55);
  ctx.textAlign = 'right';
  if (isFever) { ctx.fillStyle = '#e91e63'; ctx.font = 'bold 20px sans-serif'; ctx.fillText('üî•', W - 80, 33); }
  ctx.fillStyle = C.brown; ctx.font = 'bold 24px sans-serif';
  ctx.fillText(score.toLocaleString(), W - 15, 35);
  ctx.fillStyle = C.candy; ctx.font = '16px sans-serif';
  ctx.fillText(`üç¨ ${candies}`, W - 15, 58);

  ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(W - 30, 85, 18, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#fff'; ctx.font = '18px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('üè†', W - 30, 91);

  const gx = 20, gy = 90, gh = 200, gw = 14;
  ctx.fillStyle = '#d4a017'; rr(gx - 18, gy - 22, 50, 20, 6);
  ctx.fillStyle = '#fff'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('FEVER', gx + 7, gy - 9);
  ctx.fillStyle = 'rgba(0,0,0,.2)'; rr(gx, gy, gw, gh, 7);
  const fh = (fever / 100) * gh;
  const fg = ctx.createLinearGradient(0, gy + gh, 0, gy);
  if (isFever) { fg.addColorStop(0, '#ff4081'); fg.addColorStop(1, '#f50057'); }
  else { fg.addColorStop(0, C.bone); fg.addColorStop(1, '#d4a017'); }
  ctx.fillStyle = fg; rr(gx, gy + gh - fh, gw, Math.max(0, fh), 7);
  ctx.strokeStyle = 'rgba(0,0,0,.15)'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.roundRect(gx, gy, gw, gh, 7); ctx.stroke();
  ctx.fillStyle = '#f5e6d0'; ctx.beginPath(); ctx.arc(gx + gw / 2, gy + gh + 18, 12, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#2c2c2c';
  ctx.beginPath(); ctx.arc(gx + gw / 2 - 3, gy + gh + 15, 1.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(gx + gw / 2 + 3, gy + gh + 15, 1.5, 0, Math.PI * 2); ctx.fill();

  if (gs === STATE.PLAY && !jumpA.on) {
    ctx.globalAlpha = .1 + Math.sin(gt * .1) * .04;
    ctx.fillStyle = isFever ? '#ff69b4' : '#4a9bd9';
    ctx.font = '36px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('‚óÄ', 55, H - 40); ctx.fillText('‚ñ∂', W - 55, H - 40);
    ctx.globalAlpha = 1;
  }
  if (isFever) {
    ctx.globalAlpha = .6 + Math.sin(gt * .2) * .3;
    ctx.fillStyle = '#ff4081'; ctx.font = 'bold 18px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('üî• FEVER TIME! üî•', W / 2, H - 12);
    ctx.globalAlpha = 1;
  }
}

function drawJumpTxt() {
  if (!jumpTxt.on) return;
  jumpTxt.t--;
  if (jumpTxt.t <= 0) { jumpTxt.on = false; return; }
  const a = Math.min(1, jumpTxt.t / 10), s = .5 + (1 - jumpTxt.t / 30) * .8;
  ctx.save(); ctx.globalAlpha = a; ctx.translate(W / 2, H * 0.4); ctx.scale(s, s);
  const L = ['J','U','M','P','!'], cl = ['#5cb85c','#ffd700','#ff6b6b','#4a9bd9','#f8a4c8'];
  ctx.font = 'bold 48px sans-serif'; ctx.textAlign = 'center';
  let tw = 0; L.forEach(l => tw += ctx.measureText(l).width); let dx = -tw / 2;
  L.forEach((l, i) => {
    const b = Math.sin(gt * .12 + i * .8) * 5, r = Math.sin(gt * .09 + i) * .15;
    ctx.save(); ctx.translate(dx + ctx.measureText(l).width / 2, b); ctx.rotate(r);
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 5; ctx.strokeText(l, 0, 0);
    ctx.fillStyle = cl[i]; ctx.fillText(l, 0, 0);
    ctx.restore(); dx += ctx.measureText(l).width;
  });
  ctx.restore();
}

function drawMenu() {
  drawBG();
  ctx.fillStyle = 'rgba(255,248,240,.92)'; rr(W / 2 - 150, 120, 300, 490, 30);
  ctx.save(); ctx.translate(W / 2, 165); ctx.scale(1.5, 1.5);
  ctx.fillStyle='#f5e6d0';
  ctx.beginPath();ctx.arc(0,0,20,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(-14,-16,8,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(14,-16,8,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#e8c4a0';
  ctx.beginPath();ctx.arc(-14,-16,5,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(14,-16,5,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#2d8f4e';ctx.beginPath();ctx.arc(0,-8,16,Math.PI,0);ctx.fill();
  rr(-17,-12,34,8,3);
  ctx.fillStyle='#fff';ctx.beginPath();ctx.arc(0,-24,6,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#2c2c2c';
  ctx.beginPath();ctx.arc(-6,-2,3,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(6,-2,3,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#fff';
  ctx.beginPath();ctx.arc(-5,-3,1.2,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(7,-3,1.2,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#8B6F5E';ctx.beginPath();ctx.arc(0,3,2.5,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='rgba(255,150,150,.3)';
  ctx.beginPath();ctx.ellipse(-12,4,5,3,0,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.ellipse(12,4,5,3,0,0,Math.PI*2);ctx.fill();
  ctx.restore();
  ctx.fillStyle=C.brown;ctx.font='bold 36px sans-serif';ctx.textAlign='center';
  ctx.fillText('JUMPING PET',W/2,230);
  ctx.fillStyle='#d4a017';ctx.font='bold 28px sans-serif';ctx.fillText('Ï†êÌïëÌé´',W/2,268);
  ctx.font='24px sans-serif';ctx.fillText('‚ùÑÔ∏è',W/2-80,205);ctx.fillText('‚ùÑÔ∏è',W/2+80,205);
  ctx.fillStyle='#888';ctx.font='14px sans-serif';ctx.fillText('ÏµúÍ≥† Ï†êÏàò',W/2,320);
  ctx.fillStyle='#e91e63';ctx.font='bold 28px sans-serif';ctx.fillText(highScore.toLocaleString(),W/2,355);
  ctx.fillStyle='#999';ctx.font='12px sans-serif';
  ctx.fillText('ÌôîÎ©¥ ÏôºÏ™Ω/Ïò§Î•∏Ï™ΩÏùÑ ÌÑ∞ÏπòÌïòÏó¨ Ï†êÌîÑ!',W/2,385);
  ctx.fillText('ÏûêÎèôÏúºÎ°ú Ïò¨ÎùºÍ∞ÄÎäî ÌôîÎ©¥ÏùÑ Îî∞ÎùºÍ∞ÄÏÑ∏Ïöî',W/2,402);
  ctx.fillStyle=C.green;rr(W/2-100,425,200,55,14);
  ctx.fillStyle='rgba(255,255,255,.2)';rr(W/2-90,428,180,20,10);
  ctx.fillStyle='#fff';ctx.font='bold 22px sans-serif';ctx.fillText('ÏãúÏûëÌïòÍ∏∞',W/2,460);
  const sp=Math.sin(gt*.05)*.5+.5;
  ctx.globalAlpha=sp;ctx.fillText('‚ú®',W/2-70,455);ctx.globalAlpha=1;
  ctx.fillStyle='#aaa';ctx.font='13px sans-serif';ctx.fillText('‚óÄ ÏôºÏ™Ω ÌÉ≠ | Ïò§Î•∏Ï™Ω ÌÉ≠ ‚ñ∂',W/2,510);
  ctx.fillStyle='#e8ffe8';rr(W/2+70,140,50,50,8);
  ctx.strokeStyle='#4caf50';ctx.lineWidth=2;
  ctx.beginPath();ctx.roundRect(W/2+70,140,50,50,8);ctx.stroke();
  ctx.fillStyle='#4caf50';ctx.font='bold 14px sans-serif';ctx.fillText('ALL',W/2+95,165);
  ctx.font='9px sans-serif';ctx.fillText('Ï†ÑÏ≤¥Ïù¥Ïö©Í∞Ä',W/2+95,180);
}

function drawGameOver() {
  gameOverAlpha = Math.min(1, gameOverAlpha + 0.03);
  ctx.globalAlpha = gameOverAlpha * 0.6;
  ctx.fillStyle = '#000'; ctx.fillRect(0, 0, W, H);
  ctx.globalAlpha = gameOverAlpha;
  ctx.fillStyle = 'rgba(255,248,240,.95)'; rr(W / 2 - 140, H / 2 - 160, 280, 320, 24);
  ctx.fillStyle = '#e74c3c'; ctx.font = 'bold 32px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('GAME OVER', W / 2, H / 2 - 105);
  ctx.fillStyle = '#f5e6d0';
  ctx.beginPath(); ctx.arc(W / 2, H / 2 - 65, 18, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#2c2c2c';
  ctx.beginPath(); ctx.arc(W / 2 - 6, H / 2 - 68, 2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(W / 2 + 6, H / 2 - 68, 2, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#8B6F5E'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(W / 2, H / 2 - 56, 4, Math.PI * 1.2, Math.PI * 1.8); ctx.stroke();
  ctx.fillStyle = '#888'; ctx.font = '14px sans-serif'; ctx.fillText('Ï†êÏàò', W / 2, H / 2 - 30);
  ctx.fillStyle = C.brown; ctx.font = 'bold 36px sans-serif';
  ctx.fillText(score.toLocaleString(), W / 2, H / 2 + 10);
  ctx.fillStyle = '#888'; ctx.font = '14px sans-serif';
  ctx.fillText(`ÎÜíÏù¥: ${heightM}m | Ï∫îÎîî: ${candies}Í∞ú`, W / 2, H / 2 + 38);
  if (score >= highScore && score > 0) {
    ctx.fillStyle = '#e91e63'; ctx.font = 'bold 16px sans-serif';
    ctx.fillText('üéâ NEW RECORD! üéâ', W / 2, H / 2 + 65);
  }
  ctx.fillStyle = C.green; rr(W / 2 - 80, H / 2 + 80, 160, 48, 14);
  ctx.fillStyle = 'rgba(255,255,255,.2)'; rr(W / 2 - 72, H / 2 + 83, 144, 18, 10);
  ctx.fillStyle = '#fff'; ctx.font = 'bold 20px sans-serif';
  ctx.fillText('Îã§ÏãúÌïòÍ∏∞', W / 2, H / 2 + 111);
  ctx.fillStyle = '#ddd'; rr(W / 2 - 60, H / 2 + 138, 120, 36, 10);
  ctx.fillStyle = '#666'; ctx.font = 'bold 14px sans-serif';
  ctx.fillText('Î©îÎâ¥Î°ú', W / 2, H / 2 + 161);
  ctx.globalAlpha = 1;
}

// ============================================
// START & LOOP
// ============================================
function startGame() {
  gs = STATE.PLAY;
  score = 0; candies = 0; fever = 0; isFever = false; feverT = 0;
  heightM = 0; level = 1; autoScrollSpeed = baseAutoScroll;
  particles = []; gameOverAlpha = 0;

  initRows();
  pet.row = 0; pet.lane = 0;
  pet.x = LANE_X[0]; pet.y = rows[0].y;
  camY = pet.y - PET_SCREEN_Y;
  pet.face = 1;
  jumpA.on = false;
  jumpTxt = { on: true, t: 30 };
}

function checkGameOver() {
  const screenY = pet.y - camY;
  if (screenY + 15 > H) {
    gs = STATE.OVER;
    if (score > highScore) { highScore = score; localStorage.setItem('jpH', '' + highScore); }
  }
}

function loop() {
  gt++;
  if (gs === STATE.PLAY) {
    updateJump();
    updateCamera();

    if (isFever) {
      feverT--; applyFever();
      if (feverT <= 0) { isFever = false; fever = 0; removeFever(); }
    }
    particles = particles.filter(p => {
      p.x += p.vx; p.y += p.vy; p.vy += .1; p.life -= p.dec; return p.life > 0;
    });
    if (shakeT > 0) shakeT--;
    ensureRows();
    checkGameOver();
  }

  ctx.clearRect(0, 0, W, H);
  if (gs === STATE.MENU) { drawMenu(); }
  else {
    ctx.save();
    if (shakeT > 0) ctx.translate((Math.random()-.5)*shakeT*2,(Math.random()-.5)*shakeT*2);
    drawBG(); drawRows(); drawPet();

    // Fever sparkle stars
    if (isFever) {
      for (let i = 0; i < 12; i++) {
        const sx = (i * 71 + gt * 0.7) % W;
        const sy = (i * 97 + gt * 0.5 * (i % 3 + 1)) % H;
        const pulse = Math.sin(gt * 0.1 + i * 1.3) * 0.5 + 0.5;
        const sz = 3 + pulse * 5;
        ctx.globalAlpha = 0.3 + pulse * 0.5;
        ctx.fillStyle = i % 3 === 0 ? '#ffe066' : i % 3 === 1 ? '#ff80ab' : '#fff';
        // Draw 4-point star
        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(gt * 0.02 + i);
        ctx.beginPath();
        for (let j = 0; j < 4; j++) {
          const a = (j / 4) * Math.PI * 2 - Math.PI / 2;
          const aMid = a + Math.PI / 4;
          ctx.lineTo(Math.cos(a) * sz, Math.sin(a) * sz);
          ctx.lineTo(Math.cos(aMid) * sz * 0.3, Math.sin(aMid) * sz * 0.3);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      ctx.globalAlpha = 1;
    }
    particles.forEach(p => {
      ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
      ctx.beginPath(); ctx.arc(p.x, p.y - camY, p.sz * p.life, 0, Math.PI * 2); ctx.fill();
    });
    ctx.globalAlpha = 1; ctx.restore();
    drawJumpTxt(); drawUI();
    if (gs === STATE.OVER) drawGameOver();
  }
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
